<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Neural Core â€” Three.js</title>
  <style>
    html,body { height:100%; margin:0; background: linear-gradient(180deg,#0b0f1c 0%, #111a2e 100%); overflow:hidden; }
    #canvas { width:100%; height:100%; display:block; }
    /* subtle vignette overlay */
    .vignette {
      pointer-events:none;
      position:fixed; inset:0;
      background: radial-gradient(ellipse at center, rgba(255,255,255,0.02) 0%, rgba(0,0,0,0.45) 80%);
      mix-blend-mode: multiply;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="vignette"></div>

  <script type="module">
    // Imports (CDN)
    import * as THREE from 'https://unpkg.com/three@0.154.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.154.0/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.154.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.154.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.154.0/examples/jsm/postprocessing/UnrealBloomPass.js';

    // Basic scene setup
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.outputEncoding = THREE.sRGBEncoding;

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x081026, 0.02);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 1.2, 16);

    // Lights
    const ambient = new THREE.AmbientLight(0x2b3a7a, 0.5);
    scene.add(ambient);

    const centerLight = new THREE.PointLight(0xffb07a, 1.4, 60, 2);
    centerLight.position.set(0,0,0);
    scene.add(centerLight);

    // Postprocessing bloom
    const composer = new EffectComposer(renderer);
    composer.setSize(window.innerWidth, window.innerHeight);
    composer.addPass(new RenderPass(scene, camera));

    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.9, 0.6, 0.1);
    bloomPass.threshold = 0.1;
    bloomPass.strength = 1.2;
    bloomPass.radius = 0.8;
    composer.addPass(bloomPass);

    // Controls (optional, subtle)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableZoom = false;
    controls.minDistance = 8;
    controls.maxDistance = 30;
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.rotateSpeed = 0.2;
    controls.autoRotate = false;

    // Group that contains the neural brain
    const coreGroup = new THREE.Group();
    scene.add(coreGroup);

    // Parameters
    const FILAMENT_COUNT = 90;      // number of filaments
    const CURVE_POINTS = 7;         // control points per curve
    const SPHERE_RADIUS = 5;        // area radius
    const TUBE_SEGMENTS = 120;      // tube geometry segments
    const TUBE_RADIUS = 0.03;       // thickness of filament
    const NODE_PROB = 0.15;         // chance to place node on a filament vertex
    const particleCount = 1200;

    // utility: random point inside sphere
    function randomPointInSphere(r) {
      const u = Math.random();
      const cosT = 2 * Math.random() - 1;
      const phi = Math.acos(cosT);
      const theta = 2 * Math.PI * Math.random();
      const rad = r * Math.cbrt(u);
      const x = rad * Math.sin(phi) * Math.cos(theta);
      const y = rad * Math.sin(phi) * Math.sin(theta);
      const z = rad * Math.cos(phi);
      return new THREE.Vector3(x, y, z);
    }

    // create filaments
    const filamentMaterialBlue = new THREE.MeshStandardMaterial({
      color: 0x4fd3ff,
      emissive: 0x1f9ff0,
      emissiveIntensity: 1.4,
      metalness: 0.2,
      roughness: 0.6
    });

    const filamentMaterialOrange = new THREE.MeshStandardMaterial({
      color: 0xffb57a,
      emissive: 0xff8f3a,
      emissiveIntensity: 1.3,
      metalness: 0.15,
      roughness: 0.6
    });

    // Store per-filament animation data
    const filaments = [];

    for (let i = 0; i < FILAMENT_COUNT; i++) {
      // generate control points across sphere shell, biased toward center for crossing
      const points = [];
      for (let j = 0; j < CURVE_POINTS; j++) {
        const p = randomPointInSphere(SPHERE_RADIUS * (0.9 - Math.abs(0.5 - j / CURVE_POINTS) * 0.4));
        // add slight jitter
        p.x += (Math.random() - 0.5) * 0.6;
        p.y += (Math.random() - 0.5) * 0.6;
        p.z += (Math.random() - 0.5) * 0.6;
        points.push(p);
      }
      const curve = new THREE.CatmullRomCurve3(points);
      curve.tension = 0.9;

      // tube geometry
      const tubeGeo = new THREE.TubeGeometry(curve, TUBE_SEGMENTS, TUBE_RADIUS * (0.6 + Math.random() * 0.9), 8, false);
      // alternate materials for variety
      const mat = (i % 3 === 0) ? filamentMaterialOrange.clone() : filamentMaterialBlue.clone();
      // slightly vary emissive intensity
      mat.emissiveIntensity = 0.9 + Math.random() * 0.8;
      const mesh = new THREE.Mesh(tubeGeo, mat);
      mesh.renderOrder = 1;
      mesh.frustumCulled = false;

      // nodes along the curve
      const nodeGroup = new THREE.Group();
      const curveLen = curve.getLength();
      const nodes = [];
      for (let t = 0; t < 1.0001; t += (0.08 + Math.random() * 0.15)) {
        if (Math.random() < NODE_PROB) {
          const p = curve.getPointAt(t);
          const nodeGeo = new THREE.SphereGeometry(0.08 + Math.random() * 0.06, 10, 8);
          const nodeMat = new THREE.MeshBasicMaterial({
            color: Math.random() > 0.5 ? 0xffe1c7 : 0x9fe9ff,
            blending: THREE.AdditiveBlending
          });
          const node = new THREE.Mesh(nodeGeo, nodeMat);
          node.position.copy(p);
          node.userData.baseScale = node.scale.x;
          nodeGroup.add(node);
          nodes.push(node);
        }
      }

      // collect flicker phase
      const phase = Math.random() * Math.PI * 2;
      const sway = 0.15 + Math.random() * 0.5;

      const filamentObj = {
        mesh, curve, nodeGroup, nodes, phase, sway, mat
      };

      coreGroup.add(mesh);
      coreGroup.add(nodeGroup);
      filaments.push(filamentObj);
    }

    // Particles (floating neurons)
    const particleGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const sizes = new Float32Array(particleCount);
    const phases = new Float32Array(particleCount);
    for (let i = 0; i < particleCount; i++) {
      const p = randomPointInSphere(SPHERE_RADIUS * 1.2);
      positions[i * 3] = p.x;
      positions[i * 3 + 1] = p.y;
      positions[i * 3 + 2] = p.z;
      sizes[i] = 2 + Math.random() * 4;
      phases[i] = Math.random() * Math.PI * 2;
    }
    particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particleGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    particleGeo.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

    // Simple points material with additive blending
    const particleMat = new THREE.PointsMaterial({
      size: 0.09,
      transparent: true,
      opacity: 0.9,
      depthWrite: false,
      sizeAttenuation: true,
      map: generateSprite(),
      blending: THREE.AdditiveBlending
    });
    const particles = new THREE.Points(particleGeo, particleMat);
    particles.frustumCulled = false;
    coreGroup.add(particles);

    // tiny helper to create a soft round sprite for points
    function generateSprite() {
      const cvs = document.createElement('canvas');
      cvs.width = 64; cvs.height = 64;
      const ctx = cvs.getContext('2d');
      const grad = ctx.createRadialGradient(32,32,2,32,32,32);
      grad.addColorStop(0, 'rgba(255,255,255,1)');
      grad.addColorStop(0.2, 'rgba(200,230,255,0.9)');
      grad.addColorStop(0.45, 'rgba(80,180,255,0.5)');
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,64,64);
      const tx = new THREE.CanvasTexture(cvs);
      tx.minFilter = THREE.LinearFilter;
      tx.magFilter = THREE.LinearFilter;
      return tx;
    }

    // subtle ambient particles spin
    const particlePositions = particleGeo.attributes.position.array;
    const particlePhases = particleGeo.attributes.phase.array;

    // Interaction & animation params
    let mouseX = 0, mouseY = 0;
    let targetRotationX = 0, targetRotationY = 0;
    let lastClickTime = 0;
    let surge = 0; // when user clicks/scrolls

    window.addEventListener('mousemove', (e) => {
      const nx = (e.clientX / window.innerWidth) * 2 - 1;
      const ny = (e.clientY / window.innerHeight) * 2 - 1;
      mouseX = nx;
      mouseY = ny;
      // map to small rotation targets
      targetRotationY = nx * 0.15;
      targetRotationX = ny * 0.12;
    });

    window.addEventListener('mousedown', () => {
      lastClickTime = performance.now();
      surge = 1.6; // intensity burst
    });

    window.addEventListener('wheel', () => {
      surge = 1.0;
    }, {passive:true});

    // handle resize
    window.addEventListener('resize', onWindowResize);
    function onWindowResize() {
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    }

    // animation loop
    const clock = new THREE.Clock();
    function animate() {
      const t = clock.getElapsedTime();

      // easing surge back to zero
      surge = Math.max(0, surge - 0.02);

      // rotate core group with slight mouse-driven target
      coreGroup.rotation.y += ((targetRotationY - coreGroup.rotation.y) * 0.06) + 0.002;
      coreGroup.rotation.x += ((targetRotationX - coreGroup.rotation.x) * 0.06) + 0.001;

      // animate filaments: gentle undulation and node pulsing
      for (let i = 0; i < filaments.length; i++) {
        const f = filaments[i];
        const phase = f.phase + t * 0.8;
        const sway = f.sway;
        // update tube geometry vertices by small offset along normals using sin waves
        const geo = f.mesh.geometry;
        // update emissiveIntensity with slow pulse + surge
        const basePulse = 0.6 + Math.abs(Math.sin(phase * 0.6)) * 0.6;
        f.mat.emissiveIntensity = basePulse * (1 + surge * 0.6);

        // Animate nodes (scale flicker & emissive)
        for (let n = 0; n < f.nodes.length; n++) {
          const node = f.nodes[n];
          const ph = phase + n * 0.3;
          const scale = 0.9 + Math.abs(Math.sin(ph * 2.0)) * 0.9 + surge * 0.6;
          node.scale.setScalar(node.userData.baseScale * scale * 0.6);
          node.material.opacity = 0.6 + Math.abs(Math.sin(ph * 2.2)) * 0.6;
          node.material.needsUpdate = true;
        }

        // gentle positional sway of mesh (rotate a bit around center)
        f.mesh.rotation.x = Math.sin(phase * 0.35) * sway * 0.06;
        f.mesh.rotation.z = Math.cos(phase * 0.4) * sway * 0.04;
      }

      // animate particles
      for (let i = 0; i < particleCount; i++) {
        const idx = i * 3;
        const ph = particlePhases[i];
        // move in slow orbit based on time and phase
        const baseX = particlePositions[idx];
        const baseY = particlePositions[idx + 1];
        const baseZ = particlePositions[idx + 2];

        // small sinusoidal displacement for organic motion
        particlePositions[idx] = baseX + Math.sin(t * 0.6 + ph) * 0.06 + mouseX * 0.5;
        particlePositions[idx + 1] = baseY + Math.cos(t * 0.5 + ph * 0.8) * 0.06 + mouseY * 0.3;
        particlePositions[idx + 2] = baseZ + Math.sin(t * 0.7 + ph * 0.3) * 0.06;
      }
      particleGeo.attributes.position.needsUpdate = true;

      controls.update();

      // composer render (with bloom)
      composer.render();

      requestAnimationFrame(animate);
    }

    // tiny entrance animation: rotate and bloom ramp
    let introT = 0;
    const introDuration = 1.6;
    (function intro() {
      introT += 0.016;
      bloomPass.strength = THREE.MathUtils.lerp(0.4, 1.2, Math.min(1, introT / introDuration));
      coreGroup.rotation.y = Math.sin(introT * 0.4) * 0.4;
      if (introT < introDuration + 0.2) requestAnimationFrame(intro);
      else animate();
    })();

    // initial subtle position offsets for variety
    coreGroup.position.y = -0.4;
    coreGroup.scale.setScalar(1.05);

    // nice subtle camera float
    (function cameraFloat(){
      const t = clock.getElapsedTime();
      camera.position.x = Math.sin(t * 0.07) * 0.45 + mouseX * 1.8;
      camera.position.y = 1.2 + Math.cos(t * 0.05) * 0.25 + mouseY * 0.8;
      camera.lookAt(coreGroup.position);
      requestAnimationFrame(cameraFloat);
    })();

  </script>
</body>
</html>
